// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_SEARCH_ENGINES_TEMPLATE_URL_SERVICE_H_
#define COMPONENTS_SEARCH_ENGINES_TEMPLATE_URL_SERVICE_H_

#include <list>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "base/callback_list.h"
#include "base/gtest_prod_util.h"
#include "base/memory/scoped_ptr.h"
#include "base/observer_list.h"
#include "base/prefs/pref_change_registrar.h"
#include "components/google/core/browser/google_url_tracker.h"
#include "components/keyed_service/core/keyed_service.h"
#include "components/search_engines/default_search_manager.h"
#include "components/search_engines/keyword_web_data_service.h"
#include "components/search_engines/template_url.h"
#include "components/search_engines/template_url_id.h"
#include "components/webdata/common/web_data_service_consumer.h"
#include "sync/api/sync_change.h"
#include "sync/api/syncable_service.h"

class GURL;
class PrefService;
class SearchHostToURLsMap;
class SearchTermsData;
class TemplateURL;
struct TemplateURLData;
class TemplateURLServiceClient;
class TemplateURLServiceObserver;

namespace rappor {
class RapporService;
}

namespace syncer {
class SyncData;
class SyncErrorFactory;
}


class TemplateURLService : public WebDataServiceConsumer,
                           public KeyedService,
                           public syncer::SyncableService {
 public:
  typedef std::map<std::string, std::string> QueryTerms;
  typedef std::vector<TemplateURL*> TemplateURLVector;
  
  typedef base::Time(TimeProvider)();
  typedef std::map<std::string, syncer::SyncData> SyncDataMap;
  typedef base::CallbackList<void(void)>::Subscription Subscription;

  
  
  struct Initializer {
    const char* const keyword;
    const char* const url;
    const char* const content;
  };

  struct URLVisitedDetails {
    GURL url;
    bool is_keyword_transition;
  };

  TemplateURLService(
      PrefService* prefs,
      scoped_ptr<SearchTermsData> search_terms_data,
      const scoped_refptr<KeywordWebDataService>& web_data_service,
      scoped_ptr<TemplateURLServiceClient> client,
      GoogleURLTracker* google_url_tracker,
      rappor::RapporService* rappor_service,
      const base::Closure& dsp_change_callback);
  
  TemplateURLService(const Initializer* initializers, const int count);
  virtual ~TemplateURLService();

  
  
  
  
  
  
  static bool LoadDefaultSearchProviderFromPrefs(
      PrefService* prefs,
      scoped_ptr<TemplateURLData>* default_provider_data,
      bool* is_managed);

  
  
  static base::string16 CleanUserInputKeyword(const base::string16& keyword);

  
  
  static void SaveDefaultSearchProviderToPrefs(const TemplateURL* url,
                                               PrefService* prefs);

  
  
  
  
  
  
  
  bool CanReplaceKeyword(const base::string16& keyword,
                         const GURL& url,
                         TemplateURL** template_url_to_replace);

  
  
  
  void FindMatchingKeywords(const base::string16& prefix,
                            bool support_replacement_only,
                            TemplateURLVector* matches);

  
  
  
  
  TemplateURL* GetTemplateURLForKeyword(const base::string16& keyword);

  
  
  
  TemplateURL* GetTemplateURLForGUID(const std::string& sync_guid);

  
  
  TemplateURL* GetTemplateURLForHost(const std::string& host);

  
  
  
  bool Add(TemplateURL* template_url);

  
  
  void AddWithOverrides(TemplateURL* template_url,
                        const base::string16& short_name,
                        const base::string16& keyword,
                        const std::string& url);

  
  void AddExtensionControlledTURL(
      TemplateURL* template_url,
      scoped_ptr<TemplateURL::AssociatedExtensionInfo> info);

  
  
  void Remove(TemplateURL* template_url);

  
  
  
  void RemoveExtensionControlledTURL(const std::string& extension_id,
                                     TemplateURL::Type type);

  
  
  void RemoveAutoGeneratedSince(base::Time created_after);

  
  
  void RemoveAutoGeneratedBetween(base::Time created_after,
                                  base::Time created_before);

  
  
  
  void RemoveAutoGeneratedForOriginBetween(const GURL& origin,
                                           base::Time created_after,
                                           base::Time created_before);

  
  
  
  void RegisterOmniboxKeyword(const std::string& extension_id,
                              const std::string& extension_name,
                              const std::string& keyword,
                              const std::string& template_url_string);

  
  
  TemplateURLVector GetTemplateURLs();

  
  
  void IncrementUsageCount(TemplateURL* url);

  
  
  void ResetTemplateURL(TemplateURL* url,
                        const base::string16& title,
                        const base::string16& keyword,
                        const std::string& search_url);

  
  
  
  bool CanMakeDefault(const TemplateURL* url);

  
  
  
  void SetUserSelectedDefaultSearchProvider(TemplateURL* url);

  
  
  
  
  TemplateURL* GetDefaultSearchProvider();

  
  
  bool IsSearchResultsPageFromDefaultSearchProvider(const GURL& url);

  
  bool is_default_search_managed() const {
    return default_search_provider_source_ == DefaultSearchManager::FROM_POLICY;
  }

  
  bool IsExtensionControlledDefaultSearch();

  
  
  
  
  TemplateURL* FindNewDefaultSearchProvider();

  
  
  
  
  
  
  
  
  
  void RepairPrepopulatedSearchEngines();

  
  
  void AddObserver(TemplateURLServiceObserver* observer);
  void RemoveObserver(TemplateURLServiceObserver* observer);

  
  
  
  
  void Load();

  
  
  
  scoped_ptr<Subscription> RegisterOnLoadedCallback(
      const base::Closure& callback);

#if defined(UNIT_TEST)
  void set_loaded(bool value) { loaded_ = value; }
#endif

  
  bool loaded() { return loaded_; }

  
  
  
  virtual void OnWebDataServiceRequestDone(
      KeywordWebDataService::Handle h,
      const WDTypedResult* result) OVERRIDE;

  
  
  
  base::string16 GetKeywordShortName(const base::string16& keyword,
                                     bool* is_omnibox_api_extension_keyword);

  
  void OnHistoryURLVisited(const URLVisitedDetails& details);

  
  virtual void Shutdown() OVERRIDE;

  

  
  
  virtual syncer::SyncDataList GetAllSyncData(
      syncer::ModelType type) const OVERRIDE;
  
  
  
  virtual syncer::SyncError ProcessSyncChanges(
      const tracked_objects::Location& from_here,
      const syncer::SyncChangeList& change_list) OVERRIDE;
  
  
  
  virtual syncer::SyncMergeResult MergeDataAndStartSyncing(
      syncer::ModelType type,
      const syncer::SyncDataList& initial_sync_data,
      scoped_ptr<syncer::SyncChangeProcessor> sync_processor,
      scoped_ptr<syncer::SyncErrorFactory> sync_error_factory) OVERRIDE;
  virtual void StopSyncing(syncer::ModelType type) OVERRIDE;

  
  
  
  
  
  void ProcessTemplateURLChange(const tracked_objects::Location& from_here,
                                const TemplateURL* turl,
                                syncer::SyncChange::SyncChangeType type);

  
  const SearchTermsData& search_terms_data() const {
    return *search_terms_data_;
  }

  
  
  static syncer::SyncData CreateSyncDataFromTemplateURL(
      const TemplateURL& turl);

  
  
  
  
  
  
  
  
  static TemplateURL* CreateTemplateURLFromTemplateURLAndSyncData(
      PrefService* prefs,
      const SearchTermsData& search_terms_data,
      TemplateURL* existing_turl,
      const syncer::SyncData& sync_data,
      syncer::SyncChangeList* change_list);

  
  static SyncDataMap CreateGUIDToSyncDataMap(
      const syncer::SyncDataList& sync_data);

#if defined(UNIT_TEST)
  
  
  void set_time_provider(TimeProvider* time_provider) {
    time_provider_ = time_provider;
  }
#endif

 private:
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceTest, TestManagedDefaultSearch);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceTest,
                           UpdateKeywordSearchTermsForURL);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceTest,
                           DontUpdateKeywordSearchForNonReplaceable);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceTest, ChangeGoogleBaseValue);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceTest, MergeDeletesUnusedProviders);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceSyncTest, UniquifyKeyword);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceSyncTest,
                           IsLocalTemplateURLBetter);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceSyncTest,
                           ResolveSyncKeywordConflict);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceSyncTest, PreSyncDeletes);
  FRIEND_TEST_ALL_PREFIXES(TemplateURLServiceSyncTest, MergeInSyncTemplateURL);

  friend class InstantUnitTestBase;
  friend class TemplateURLServiceTestUtil;

  typedef std::map<base::string16, TemplateURL*> KeywordToTemplateMap;
  typedef std::map<std::string, TemplateURL*> GUIDToTemplateMap;

  
  
  
  
  enum DefaultSearchChangeOrigin {
    
    DSP_CHANGE_SYNC_PREF,
    DSP_CHANGE_SYNC_ADD,
    DSP_CHANGE_SYNC_DELETE,
    DSP_CHANGE_SYNC_NOT_MANAGED,
    
    
    
    DSP_CHANGE_SYNC_UNINTENTIONAL,
    
    
    DSP_CHANGE_OTHER,
    
    DSP_CHANGE_PROFILE_RESET,
    
    DSP_CHANGE_OVERRIDE_SETTINGS_EXTENSION,
    
    
    
    DSP_CHANGE_NEW_ENGINE_NO_PREFS,
    
    DSP_CHANGE_MAX,
  };

  
  
  class LessWithPrefix;

  void Init(const Initializer* initializers, int num_initializers);

  void RemoveFromMaps(TemplateURL* template_url);

  void AddToMaps(TemplateURL* template_url);

  
  
  
  
  
  
  void SetTemplateURLs(TemplateURLVector* urls);

  
  void ChangeToLoadedState();

  
  
  void OnDefaultSearchChange(const TemplateURLData* new_dse_data,
                             DefaultSearchManager::Source source);

  
  void ApplyDefaultSearchChange(const TemplateURLData* new_dse_data,
                                DefaultSearchManager::Source source);


  
  
  bool ApplyDefaultSearchChangeNoMetrics(const TemplateURLData* new_dse_data,
                                         DefaultSearchManager::Source source);

  
  
  
  bool CanReplaceKeywordForHost(const std::string& host,
                                TemplateURL** to_replace);

  
  
  
  
  bool CanReplace(const TemplateURL* t_url);

  
  TemplateURL* FindNonExtensionTemplateURLForKeyword(
      const base::string16& keyword);

  
  
  
  
  
  
  
  bool UpdateNoNotify(TemplateURL* existing_turl,
                      const TemplateURL& new_values);

  
  
  
  
  static void UpdateTemplateURLIfPrepopulated(TemplateURL* existing_turl,
                                              PrefService* prefs);

  
  
  
  void MaybeUpdateDSEAfterSync(TemplateURL* synced_turl);

  
  
  
  void UpdateKeywordSearchTermsForURL(const URLVisitedDetails& details);

  
  void AddTabToSearchVisit(const TemplateURL& t_url);

  
  void RequestGoogleURLTrackerServerCheckIfNecessary();

  
  
  
  void GoogleBaseURLChanged();

  
  
  
  
  
  
  
  
  
  
  bool AddNoNotify(TemplateURL* template_url, bool newly_adding);

  
  
  
  void RemoveNoNotify(TemplateURL* template_url);

  
  
  bool ResetTemplateURLNoNotify(TemplateURL* url,
                                const base::string16& title,
                                const base::string16& keyword,
                                const std::string& search_url);

  
  
  void NotifyObservers();

  
  
  
  void UpdateProvidersCreatedByPolicy(
      TemplateURLVector* template_urls,
      const TemplateURLData* default_from_prefs);

  
  
  void ResetTemplateURLGUID(TemplateURL* url, const std::string& guid);

  
  
  
  
  
  
  base::string16 UniquifyKeyword(const TemplateURL& turl, bool force);

  
  
  
  
  
  
  
  
  
  bool IsLocalTemplateURLBetter(const TemplateURL* local_turl,
                                const TemplateURL* sync_turl);

  
  
  
  
  
  
  
  
  void ResolveSyncKeywordConflict(TemplateURL* unapplied_sync_turl,
                                  TemplateURL* applied_sync_turl,
                                  syncer::SyncChangeList* change_list);

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  void MergeInSyncTemplateURL(TemplateURL* sync_turl,
                              const SyncDataMap& sync_data,
                              syncer::SyncChangeList* change_list,
                              SyncDataMap* local_data,
                              syncer::SyncMergeResult* merge_result);

  
  
  
  void PatchMissingSyncGUIDs(TemplateURLVector* template_urls);

  void OnSyncedDefaultSearchProviderGUIDChanged();

  
  
  
  
  
  
  void AddTemplateURLs(TemplateURLVector* template_urls);

  
  TemplateURL* FindPrepopulatedTemplateURL(int prepopulated_id);

  
  TemplateURL* FindTemplateURLForExtension(const std::string& extension_id,
                                           TemplateURL::Type type);

  
  TemplateURL* FindMatchingExtensionTemplateURL(const TemplateURLData& data,
                                                TemplateURL::Type type);

  
  
  
  
  void UpdateExtensionDefaultSearchEngine();


  
  PrefService* prefs_;

  scoped_ptr<SearchTermsData> search_terms_data_;

  
  
  scoped_refptr<KeywordWebDataService> web_data_service_;

  scoped_ptr<TemplateURLServiceClient> client_;

  GoogleURLTracker* google_url_tracker_;

  
  rappor::RapporService* rappor_service_;

  
  base::Closure dsp_change_callback_;


  PrefChangeRegistrar pref_change_registrar_;

  
  KeywordToTemplateMap keyword_to_template_map_;

  
  GUIDToTemplateMap guid_to_template_map_;

  TemplateURLVector template_urls_;

  ObserverList<TemplateURLServiceObserver> model_observers_;

  
  
  
  scoped_ptr<SearchHostToURLsMap> provider_map_;

  
  bool loaded_;

  
  
  
  bool load_failed_;

  
  KeywordWebDataService::Handle load_handle_;

  
  
  std::vector<URLVisitedDetails> visits_to_add_;

  
  
  TemplateURL* default_search_provider_;

  
  
  scoped_ptr<TemplateURL> initial_default_search_provider_;

  
  DefaultSearchManager::Source default_search_provider_source_;

  
  
  TemplateURLID next_id_;

  
  TimeProvider* time_provider_;

  
  
  
  
  bool models_associated_;

  
  
  bool processing_syncer_changes_;

  
  scoped_ptr<syncer::SyncChangeProcessor> sync_processor_;

  
  scoped_ptr<syncer::SyncErrorFactory> sync_error_factory_;

  
  
  
  
  
  std::set<std::string> pre_sync_deletes_;

  
  
  
  DefaultSearchChangeOrigin dsp_change_origin_;

  
  base::CallbackList<void(void)> on_loaded_callbacks_;

  
  DefaultSearchManager default_search_manager_;

  scoped_ptr<GoogleURLTracker::Subscription> google_url_updated_subscription_;

  DISALLOW_COPY_AND_ASSIGN(TemplateURLService);
};

#endif  
